<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제퍼디 퀴즈 게임판</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 15px 15px 25px 15px;
            box-sizing: border-box;
        }

        #gameBoard {
            flex-grow: 1;
            border-collapse: collapse;
            table-layout: fixed;
            width: 100%;
        }

        #gameBoard th, #gameBoard td {
            border: 2px solid black;
            text-align: center;
            vertical-align: middle;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 5px;
            height: 18vh;
            transition: background-color 0.3s ease, color 0.3s ease, font-size 0.1s linear, font-weight 0.1s linear, height 0.2s ease;
        }

        #gameBoard th.category-header {
            background-color: #007bff;
            color: yellow;
            font-weight: bold;
            font-size: 50px; /* Default size */
            white-space: normal;
            word-break: break-word;
            cursor: default;
            height: 12vh;
        }
        #gameBoard th.category-header.clickable { cursor: pointer; }
        #gameBoard th.category-header.clickable:hover { background-color: #0056b3; }

        .question-cell {
            background-color: blue;
            color: yellow;
            font-size: 60px; /* Default size */
            font-weight: bold;
            cursor: pointer;
        }

        .question-cell:hover:not(.used) { background-color: #0000CD; }

        .question-cell.used {
            background-color: grey;
            color: #e0e0e0;
            cursor: pointer;
        }
        .question-cell.used:hover { background-color: #777; }

        /* --- Settings Button and Menu --- */
        #settingsButton {
            position: fixed; top: 15px; right: 15px;
            padding: 10px 15px; background-color: #6c757d; color: white;
            border: none; border-radius: 5px; cursor: pointer; z-index: 1001;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #settingsButton:hover { background-color: #5a6268; }

        #settingsMenu {
            display: none; position: fixed; top: 60px; right: 15px;
            width: 320px; max-height: calc(100vh - 80px); overflow-y: auto;
            background-color: #f8f9fa; border: 1px solid #ccc; border-radius: 5px;
            padding: 20px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        #settingsMenu h3 {
            margin-top: 0; margin-bottom: 15px; text-align: center;
            border-bottom: 1px solid #ddd; padding-bottom: 10px;
        }
        .settings-section { margin-bottom: 20px; }
        .settings-section label { display: block; margin-bottom: 5px; font-weight: bold; }
        .settings-section input[type="range"] { width: calc(100% - 45px); vertical-align: middle; }
        .settings-section input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
        .settings-section button, .settings-section input[type="file"] {
            margin-top: 10px; padding: 8px 12px; border-radius: 4px;
            border: 1px solid #ccc; display: block; width: 100%;
            box-sizing: border-box; text-align: center;
        }
        .settings-section button { cursor: pointer; background-color: #007bff; color: white; border: none; }
        .settings-section button:hover { background-color: #0056b3; }
        #settingsMenu button#toggleEditModeSettings.edit-mode { background-color: #f44336; }
        #settingsMenu button#resetBoardSettings { background-color: #ffc107; color: #333; }
        #settingsMenu button#resetBoardSettings:hover { background-color: #e0a800; }
        .settings-section button#closeSettingsBtn { margin-top: 15px; background-color: #6c757d; }

        .setting-value-display {
            display: inline-block; min-width: 35px;
            text-align: right; margin-left: 5px; font-size: 0.9em;
            color: #555; vertical-align: middle;
        }

        /* --- Modals --- */
        /* Ensure modals are hidden initially and provide centering */
        .modal {
            display: none; /* Crucial: Hide initially */
            position: fixed;
            z-index: 999;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: hidden; /* Prevent body scroll */
            background-color: rgba(0,0,0,0.6);
            /* --- Flexbox for centering --- */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* --- Content styling --- */
        .modal-content {
            background-color: #fefefe;
            margin: 0; /* Let flexbox handle centering */
            padding: 30px 40px;
            border: 1px solid #888;
            width: 80%;
            max-width: 900px;
            border-radius: 8px;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
            position: relative; /* For close button positioning */
            max-height: 85vh; /* Limit height */
            overflow-y: auto; /* Allow content scroll */
            display: flex; /* Use flex for internal layout */
            flex-direction: column; /* Stack content vertically */
        }
        .close-btn {
            color: #aaa; position: absolute; top: 10px; right: 25px;
            font-size: 32px; font-weight: bold; cursor: pointer;
        }
        .close-btn:hover, .close-btn:focus { color: black; text-decoration: none; }

        /* Question Modal Specific */
        #modalCategoryScore { margin-bottom: 25px; flex-shrink: 0; }
        #modalQuestion {
            margin-top: 15px; margin-bottom: 20px;
            font-size: 50px; /* Default hint size, JS overrides */
            line-height: 1.7;
            min-height: 200px;
            font-weight: 500; padding: 20px;
            background-color: #f8f9fa; border-left: 5px solid #007bff;
            border-radius: 4px;
            overflow-y: auto;
            flex-grow: 1;
        }

        #modalActions { flex-shrink: 0; }
        #modalActions button {
            padding: 12px 18px; margin-right: 10px; cursor: pointer;
            border: none; border-radius: 4px;
        }
        #closeModalBtn{ background-color: #6c757d; color: white; }

         /* Edit Modal Specific Styles - Override flex centering */
         #editModal .modal-content {
             width: 70%; max-width: 700px;
             max-height: 80vh;
             display: block; /* Override flex for standard block layout */
             /* Margin auto needed again if not using flex centering for this specific modal */
             margin: auto;
         }
         #editModal label { display: block; margin-top: 15px; font-weight: bold; }
         #editModal input[type="text"], #editModal textarea {
             width: 95%; padding: 10px; margin-top: 5px;
             border: 1px solid #ccc; border-radius: 4px; font-size: 1em;
         }
         #editModal textarea { height: 100px; resize: vertical; }
         #saveEditBtn { background-color: #28a745; color: white; }
         #cancelEditBtn { background-color: #dc3545; color: white; }

    </style>
</head>
<body>

    <div id="gameContainer">
        <table id="gameBoard">
            <thead>
                <tr id="categoryHeaders">
                    <!-- Categories will be loaded here -->
                </tr>
            </thead>
            <tbody id="questionGrid">
                <!-- Questions will be loaded here -->
            </tbody>
        </table>
    </div>

    <button id="settingsButton">설정</button>

    <div id="settingsMenu">
        <h3>설정</h3>

        <div class="settings-section">
            <label>CSV 데이터</label>
            <button id="downloadTemplateBtn">CSV 양식 다운로드</button>
            <label for="csvFileInputSettings" style="margin-top: 10px;">CSV 파일 업로드:</label>
            <input type="file" id="csvFileInputSettings" accept=".csv" style="border: none; padding: 0;">
        </div>

        <div class="settings-section font-setting">
            <label for="categoryFontSize">카테고리 글자 크기:</label>
            <input type="range" id="categoryFontSize" min="20" max="80" value="50">
            <span class="setting-value-display" id="categoryFontSizeValue">50px</span>
            <label style="display: inline-block; margin-left: 10px;">
                <input type="checkbox" id="categoryFontBold" checked> 굵게
            </label>
        </div>

        <div class="settings-section font-setting">
            <label for="scoreFontSize">점수/확인 글자 크기:</label>
            <input type="range" id="scoreFontSize" min="30" max="100" value="60">
             <span class="setting-value-display" id="scoreFontSizeValue">60px</span>
            <label style="display: inline-block; margin-left: 10px;">
                <input type="checkbox" id="scoreFontBold" checked> 굵게
            </label>
        </div>

        <div class="settings-section font-setting">
            <label for="hintFontSize">힌트 글자 크기:</label>
            <!-- Default 50px, range 30-80 -->
            <input type="range" id="hintFontSize" min="30" max="80" value="50">
            <span class="setting-value-display" id="hintFontSizeValue">50px</span>
        </div>

         <div class="settings-section cell-height-setting">
            <label for="categoryHeight">카테고리 행 높이:</label>
            <input type="range" id="categoryHeight" min="5" max="30" value="12">
            <span class="setting-value-display" id="categoryHeightValue">12vh</span>
        </div>

        <div class="settings-section cell-height-setting">
            <label for="scoreHeight">점수 행 높이:</label>
            <input type="range" id="scoreHeight" min="10" max="40" value="18">
            <span class="setting-value-display" id="scoreHeightValue">18vh</span>
        </div>


        <div class="settings-section">
             <label>게임 관리</label>
             <button id="toggleEditModeSettings">편집 모드 켜기</button>
             <button id="resetBoardSettings">게임판 초기화</button>
        </div>

         <button id="closeSettingsBtn" onclick="toggleSettingsMenu(false)">닫기</button>
    </div>


    <!-- Question Display Modal -->
    <div id="questionModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('questionModal')">×</span>
            <h2 id="modalCategoryScore"></h2>
            <p style="flex-shrink: 0;"><strong>힌트 (문제):</strong></p>
            <div id="modalQuestion"></div>
            <div id="modalActions" style="margin-top: 20px; text-align: right; flex-shrink: 0;">
                <button id="closeModalBtn" onclick="closeModal('questionModal')">닫기</button>
            </div>
        </div>
    </div>

    <!-- Edit Question/Hint Modal -->
    <div id="editModal" class="modal"> <!-- Note: ID is used for targeting -->
        <div class="modal-content">
             <span class="close-btn" onclick="closeModal('editModal')">×</span>
             <h2 id="editModalTitle">문제(힌트) 수정</h2>
             <p>카테고리명과 정답은 카테고리 헤더를 직접 클릭하여 수정하세요.</p>
             <div>
                 <label for="editQuestion">문제 (힌트 내용):</label>
                 <textarea id="editQuestion"></textarea>
             </div>
              <input type="hidden" id="editCategoryIndex">
              <input type="hidden" id="editScore">
             <div id="modalActions" style="margin-top: 20px;">
                 <button id="saveEditBtn">힌트 저장</button>
                 <button id="cancelEditBtn" onclick="closeModal('editModal')">취소</button>
             </div>
        </div>
    </div>


    <script>
        let categories = ["1번", "2번", "3번", "4번", "5번", "6번", "7번", "8번"];
        const scores = [100, 200, 300, 400];
        let gameData = {};
        let isEditMode = false;
        let currentEditingCell = null;

        // DOM Elements
        const gameBoard = document.getElementById('gameBoard');
        const categoryHeadersRow = document.getElementById('categoryHeaders');
        const questionGrid = document.getElementById('questionGrid');
        const questionModal = document.getElementById('questionModal');
        const editModal = document.getElementById('editModal');
        const modalQuestionDiv = document.getElementById('modalQuestion');

        // Settings Elements
        const settingsButton = document.getElementById('settingsButton');
        const settingsMenu = document.getElementById('settingsMenu');
        const csvFileInputSettings = document.getElementById('csvFileInputSettings');
        const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
        const categoryFontSizeSlider = document.getElementById('categoryFontSize');
        const categoryFontBoldCheckbox = document.getElementById('categoryFontBold');
        const scoreFontSizeSlider = document.getElementById('scoreFontSize');
        const scoreFontBoldCheckbox = document.getElementById('scoreFontBold');
        const hintFontSizeSlider = document.getElementById('hintFontSize');
        const categoryHeightSlider = document.getElementById('categoryHeight');
        const scoreHeightSlider = document.getElementById('scoreHeight');
        const categoryFontSizeValueSpan = document.getElementById('categoryFontSizeValue');
        const scoreFontSizeValueSpan = document.getElementById('scoreFontSizeValue');
        const hintFontSizeValueSpan = document.getElementById('hintFontSizeValue');
        const categoryHeightValueSpan = document.getElementById('categoryHeightValue');
        const scoreHeightValueSpan = document.getElementById('scoreHeightValue');
        const toggleEditModeSettingsBtn = document.getElementById('toggleEditModeSettings');
        const resetBoardSettingsBtn = document.getElementById('resetBoardSettings');


        // --- Initialization ---
        function initializeBoard(useDefaultCategories = true) {
             categoryHeadersRow.innerHTML = '';
            questionGrid.innerHTML = '';
            const tempGameData = JSON.parse(JSON.stringify(gameData));
            gameData = {};

            if (!useDefaultCategories && Object.keys(tempGameData).length > 0) {
                 const loadedCategories = Object.keys(tempGameData);
                 categories.length = 0;
                 categories.push(...loadedCategories.slice(0, 8));
                 while (categories.length < 8) categories.push(`${categories.length + 1}번`);
                 categories = categories.slice(0, 8);
                 categories.forEach(cat => {
                     gameData[cat] = tempGameData[cat] || createDefaultCategoryData(cat);
                 });
            } else {
                 categories.length = 0;
                 for(let i = 1; i <= 8; i++) categories.push(`${i}번`);
                 categories.forEach(cat => {
                    gameData[cat] = createDefaultCategoryData(cat);
                 });
            }

            // Create Headers
            categories.forEach((cat, index) => {
                const th = document.createElement('th');
                th.textContent = cat;
                th.classList.add('category-header');
                th.dataset.categoryIndex = index;
                th.dataset.categoryName = cat;
                th.dataset.displayState = 'category';
                categoryHeadersRow.appendChild(th);
            });

            // Create Question Grid
            scores.forEach(score => {
                const tr = document.createElement('tr');
                categories.forEach((cat, catIndex) => {
                    const td = document.createElement('td');
                    td.classList.add('question-cell');
                    td.dataset.category = cat;
                    td.dataset.score = score;
                    td.dataset.categoryIndex = catIndex;

                    const scoreData = gameData[cat]?.scores?.[score];
                    if (scoreData?.used) {
                        td.textContent = '확인';
                        td.classList.add('used');
                    } else {
                        td.textContent = `${score}점`;
                    }
                    tr.appendChild(td);
                });
                questionGrid.appendChild(tr);
            });

            // Apply settings AFTER elements are created
            applyFontSettings();
            applyHeightSettings();
            applyHintFontSize(); // Apply initial hint font size to the (hidden) modal div
            updateHintFontSizeDisplay(); // Update the display span in settings

            // Set up listeners and initial UI states
            updateCategoryHeaderListeners();
            updateEditModeVisuals();
            console.log("Board initialized/updated. Current gameData:", gameData);
        }

        function createDefaultCategoryData(categoryName) {
             const defaultData = {
                 answer: `(${categoryName} 정답)`,
                 attempted: false,
                 scores: {}
             };
             scores.forEach(score => {
                 defaultData.scores[score] = { q: `(${categoryName} - ${score}점 힌트)`, used: false };
             });
             return defaultData;
        }


        // --- Event Listeners ---
        settingsButton.addEventListener('click', toggleSettingsMenu);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F2') { e.preventDefault(); toggleSettingsMenu(); }
            if (e.key === 'Escape') {
                 closeModal('questionModal');
                 closeModal('editModal');
                 toggleSettingsMenu(false);
            }
        });

        csvFileInputSettings.addEventListener('change', handleFileUpload);
        downloadTemplateBtn.addEventListener('click', downloadCsvTemplate);
        questionGrid.addEventListener('click', handleCellClick);
        categoryHeadersRow.addEventListener('click', handleCategoryHeaderClick);

        // Settings Listeners
        categoryFontSizeSlider.addEventListener('input', handleFontSettingChange);
        categoryFontBoldCheckbox.addEventListener('change', handleFontSettingChange);
        scoreFontSizeSlider.addEventListener('input', handleFontSettingChange);
        scoreFontBoldCheckbox.addEventListener('change', handleFontSettingChange);
        hintFontSizeSlider.addEventListener('input', handleHintFontSettingChange);
        categoryHeightSlider.addEventListener('input', handleHeightSettingChange);
        scoreHeightSlider.addEventListener('input', handleHeightSettingChange);

        toggleEditModeSettingsBtn.addEventListener('click', toggleEditMode);
        resetBoardSettingsBtn.addEventListener('click', () => {
            if (confirm("정말로 게임판을 초기 상태로 되돌리시겠습니까? 입력된 모든 내용과 진행 상태가 사라집니다.")) {
                // Reset sliders to default values before initializing
                categoryFontSizeSlider.value = 50;
                scoreFontSizeSlider.value = 60;
                hintFontSizeSlider.value = 50;
                categoryHeightSlider.value = 12;
                scoreHeightSlider.value = 18;
                categoryFontBoldCheckbox.checked = true;
                scoreFontBoldCheckbox.checked = true;

                initializeBoard(true); // Re-initialize with defaults and apply settings
                isEditMode = false;
                updateEditMode(); // Update button state
                alert("게임판이 초기화되었습니다.");
                toggleSettingsMenu(false);
            }
        });

        document.getElementById('saveEditBtn').addEventListener('click', saveEdit);

        // --- Modal Handling ---
        function closeModal(modalId) {
             // Use flex display none for question modal, block for edit modal
            const modal = document.getElementById(modalId);
             if(modal) {
                 // Check which modal it is to apply correct display: none; logic
                 // No need to check, just set display to none.
                 // The parent (.modal) should handle the flex display correctly when shown again.
                 modal.style.display = 'none';
             }
            if (modalId === 'editModal') currentEditingCell = null;
        }

         // Function to show a modal (ensures correct display type for centering)
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                // Always use 'flex' for the parent modal container to enable centering
                modal.style.display = 'flex';
            }
        }


        // --- Category Header Click Handling ---
        function handleCategoryHeaderClick(event) {
            const th = event.target.closest('th.category-header');
            if (!th) return;

            const categoryIndex = parseInt(th.dataset.categoryIndex);
            const categoryName = th.dataset.categoryName;

             if (isEditMode) {
                 const currentAnswer = gameData[categoryName]?.answer || '';
                 const newCategoryName = prompt(`[편집] '${categoryName}' 카테고리의 새 이름을 입력하세요:`, categoryName);

                 if (newCategoryName && newCategoryName.trim() !== "") {
                     const newAnswer = prompt(`[편집] '${newCategoryName}' 카테고리의 정답을 입력하세요:`, (newCategoryName === categoryName) ? currentAnswer : `(${newCategoryName} 정답)`);

                     if (newAnswer === null) return;

                     const nameExists = categories.some((cat, idx) => idx !== categoryIndex && cat === newCategoryName);
                     if (newCategoryName !== categoryName && nameExists) {
                         alert("오류: 해당 카테고리 이름이 이미 존재합니다.");
                         return;
                     }

                     const oldCategoryName = categoryName;
                     categories[categoryIndex] = newCategoryName;

                     if (newCategoryName !== oldCategoryName) {
                         gameData[newCategoryName] = gameData[oldCategoryName] || createDefaultCategoryData(newCategoryName);
                         gameData[newCategoryName].answer = newAnswer.trim();
                         if (gameData[oldCategoryName]) delete gameData[oldCategoryName];

                         questionGrid.querySelectorAll(`td[data-category-index="${categoryIndex}"]`).forEach(cell => {
                             cell.dataset.category = newCategoryName;
                         });
                          th.dataset.categoryName = newCategoryName;
                     } else {
                          if(gameData[categoryName]) {
                              gameData[categoryName].answer = newAnswer.trim();
                          } else {
                              gameData[categoryName] = createDefaultCategoryData(categoryName);
                              gameData[categoryName].answer = newAnswer.trim();
                          }
                     }

                     th.textContent = newCategoryName;
                     th.dataset.displayState = 'category';

                     console.log(`Category updated: ${oldCategoryName} -> ${newCategoryName}, Answer: ${gameData[newCategoryName]?.answer}`);
                 }

             } else {
                 // Play Mode: Toggle Answer in Header Cell
                 const categoryData = gameData[categoryName];
                 if (categoryData?.attempted) {
                     const currentDisplayState = th.dataset.displayState || 'category';
                     if (currentDisplayState === 'category') {
                         th.textContent = categoryData.answer || '(정답 없음)';
                         th.dataset.displayState = 'answer';
                     } else {
                         th.textContent = categoryName;
                         th.dataset.displayState = 'category';
                     }
                     applyFontSettings(); // Re-apply font settings to header
                 }
             }
        }

        function updateCategoryHeaderListeners() {
             document.querySelectorAll('#categoryHeaders .category-header').forEach(th => {
                 const categoryName = th.dataset.categoryName;
                 const categoryData = gameData[categoryName];
                 th.classList.remove('clickable');
                 th.title = "";

                 if (isEditMode) {
                     th.classList.add('clickable');
                     th.title = "[편집] 클릭하여 카테고리 이름/정답 수정";
                 } else if (categoryData?.attempted) {
                     th.classList.add('clickable');
                     th.title = "[플레이] 클릭하여 정답 확인/숨기기";
                 }
             });
        }


        // --- Core Logic ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                if (parseCSV(e.target.result)) {
                    alert("CSV 파일 로드가 완료되었습니다!");
                    toggleSettingsMenu(false);
                }
                event.target.value = null;
            };
            reader.onerror = () => alert("파일 읽기 오류");
            reader.readAsText(file, 'UTF-8');
        }

        function parseCSV(csvText) {
            try {
                const lines = csvText.trim().split(/\r?\n/);
                if (lines.length < 2) throw new Error("CSV 데이터 부족");

                const headers = lines[0].split(',').map(h => h.trim());
                const catIdx = headers.indexOf('Category');
                const scoreIdx = headers.indexOf('Score');
                const qIdx = headers.indexOf('Question');
                const aIdx = headers.indexOf('Answer');
                if ([catIdx, scoreIdx, qIdx, aIdx].includes(-1)) throw new Error("필수 헤더(Category, Score, Question, Answer) 누락");

                const loadedData = {};
                const loadedCategoriesOrder = [];

                for (let i = 1; i < lines.length; i++) {
                    const values = parseCsvLine(lines[i]);
                    if (values.length <= Math.max(catIdx, scoreIdx, qIdx, aIdx)) continue;

                    const category = values[catIdx]?.trim();
                    const score = parseInt(values[scoreIdx]?.trim());
                    const question = values[qIdx]?.trim();
                    const answer = values[aIdx]?.trim();

                    if (!category || isNaN(score) || !scores.includes(score)) continue;

                    if (!loadedData[category]) {
                        loadedData[category] = createDefaultCategoryData(category);
                        loadedData[category].answer = answer || `(${category} 정답)`;
                        loadedCategoriesOrder.push(category);
                    }
                    loadedData[category].scores[score] = {
                         q: question || `(${category} - ${score}점 힌트)`,
                         used: false
                    };
                }

                gameData = loadedData;
                categories.length = 0;
                categories.push(...loadedCategoriesOrder);
                initializeBoard(false); // Rebuild board and apply settings
                return true;

            } catch (error) {
                alert(`CSV 파싱 오류: ${error.message}. 콘솔 확인.`);
                console.error("CSV Parsing Error:", error);
                return false;
            }
        }

        function parseCsvLine(line) {
            const values = [];
            let currentVal = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i+1] === '"') { currentVal += '"'; i++; }
                    else { inQuotes = !inQuotes; }
                } else if (char === ',' && !inQuotes) {
                    values.push(currentVal); currentVal = '';
                } else { currentVal += char; }
            }
            values.push(currentVal);
            return values.map(v => v.trim());
        }

        function handleCellClick(event) {
            const target = event.target.closest('td.question-cell');
            if (!target) return;

            const category = target.dataset.category;
            const score = parseInt(target.dataset.score);
            const categoryIndex = parseInt(target.dataset.categoryIndex);
            const categoryData = gameData[category];
            const scoreData = categoryData?.scores?.[score];

            if (!categoryData || !scoreData) {
                alert("오류: 해당 문제 데이터를 찾을 수 없습니다.");
                return;
            }

            if (isEditMode) {
                // Edit Mode
                currentEditingCell = target;
                document.getElementById('editModalTitle').textContent = `'${category}' - ${score}점 힌트 수정`;
                document.getElementById('editQuestion').value = scoreData.q;
                document.getElementById('editCategoryIndex').value = categoryIndex;
                document.getElementById('editScore').value = score;
                // Use showModal for edit modal as well, its CSS will handle layout
                showModal('editModal');
            } else {
                // Play Mode
                if (target.classList.contains('used')) {
                    // Revert Cell
                    target.classList.remove('used');
                    target.textContent = `${score}점`;
                    scoreData.used = false;

                    const isAnyOtherUsed = scores.some(s => gameData[category]?.scores?.[s]?.used);
                    if (!isAnyOtherUsed && gameData[category]) {
                         gameData[category].attempted = false;
                         const header = categoryHeadersRow.querySelector(`th[data-category-index="${categoryIndex}"]`);
                         if(header && header.dataset.displayState === 'answer') {
                             header.textContent = category;
                             header.dataset.displayState = 'category';
                             applyFontSettings();
                         }
                         updateCategoryHeaderListeners();
                    }
                } else {
                    // Show Hint Modal
                    document.getElementById('modalCategoryScore').textContent = `${category} - ${score}점`;
                    modalQuestionDiv.innerHTML = scoreData.q.replace(/\n/g, '<br>');
                    applyHintFontSize(); // Apply current hint font size setting
                    showModal('questionModal'); // Use showModal for centering

                    // Mark as used AFTER showing modal
                    target.classList.add('used');
                    target.textContent = '확인';
                    scoreData.used = true;
                    if(categoryData) categoryData.attempted = true;
                    updateCategoryHeaderListeners();
                }
                 applyFontSettings(); // Apply score/check font settings
            }
        }

         function saveEdit() {
             const questionHint = document.getElementById('editQuestion').value;
             const categoryIndex = parseInt(document.getElementById('editCategoryIndex').value);
             const score = parseInt(document.getElementById('editScore').value);
             const categoryName = categories[categoryIndex];

             if (categoryName && !isNaN(score) && gameData[categoryName]?.scores?.[score]) {
                 gameData[categoryName].scores[score].q = questionHint;
                 closeModal('editModal');
                 alert("힌트가 저장되었습니다.");
             } else {
                  alert("오류: 힌트 저장 중 오류 발생.");
             }
         }

        // --- Settings Menu Logic ---
        function toggleSettingsMenu(forceState = null) {
            const isOpen = settingsMenu.style.display === 'block';
            const newState = forceState === null ? !isOpen : forceState;
            settingsMenu.style.display = newState ? 'block' : 'none';
        }

        function downloadCsvTemplate() {
            const csvContent = `Category,Score,Question,Answer
"1번",100,"사람들이 돈을 맡기거나 빌릴 수 있는 곳이에요.","하나은행"
"1번",200,"사람들의 돈을 안전하게 보관하고, 이자를 주거나 대출도 해주는 금융기관이에요. 앱이나 인터넷으로도 이용할 수 있어요.","하나은행"
"1번",300,"개인과 기업을 대상으로 다양한 금융 상품을 제공하며, 해외 사업과 디지털 금융에도 힘쓰고 있는 국내 주요 은행 중 하나입니다.","하나은행"
"1번",400,"하나금융그룹의 주력 계열사로, 글로벌 자산관리(WM), 외환, 디지털 트랜스포메이션 전략을 기반으로 지속가능한 금융 성장을 추구하며, 신탁과 ESG 금융 등 고도화된 서비스도 제공하고 있습니다.","하나은행"
"2번",100,"사람들이 휴대전화로 통화하고 인터넷을 쓸 수 있게 해주는 회사예요.","SKT"
"2번",200,"휴대전화 통신 서비스를 제공하는 회사로, 5G나 인공지능 같은 미래 기술도 개발하고 있어요.","SKT"
"2번",300,"국내 최대 이동통신사 중 하나로, 5G, AI, 미디어, 데이터센터 등 다양한 ICT 사업으로 영역을 확장하고 있습니다.","SKT"
"2번",400,"MNO 기반의 안정적 수익구조를 바탕으로 AI 컴퍼니로 전환을 추진 중이며, AIVERSE 생태계 구축, 초거대 AI 모델 개발, 클라우드 및 B2B 솔루션 강화로 디지털 혁신을 선도하고 있습니다.","SKT"
`;
            const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "jeopardy_template.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // --- Font and Height Settings ---
        function handleFontSettingChange() {
             applyFontSettings();
             categoryFontSizeValueSpan.textContent = categoryFontSizeSlider.value + 'px';
             scoreFontSizeValueSpan.textContent = scoreFontSizeSlider.value + 'px';
        }

        function applyFontSettings() {
            const catSize = categoryFontSizeSlider.value + 'px';
            const catBold = categoryFontBoldCheckbox.checked ? 'bold' : 'normal';
            const scoreSize = scoreFontSizeSlider.value + 'px';
            const scoreBold = scoreFontBoldCheckbox.checked ? 'bold' : 'normal';

            document.querySelectorAll('#gameBoard th.category-header').forEach(th => {
                th.style.fontSize = catSize;
                th.style.fontWeight = catBold;
            });
            document.querySelectorAll('#gameBoard td.question-cell').forEach(td => {
                td.style.fontSize = scoreSize;
                td.style.fontWeight = scoreBold;
            });
        }

        function handleHintFontSettingChange() {
            updateHintFontSizeDisplay();
            applyHintFontSize(); // Apply change live
        }

        function updateHintFontSizeDisplay() {
             if (hintFontSizeSlider && hintFontSizeValueSpan) {
                 hintFontSizeValueSpan.textContent = hintFontSizeSlider.value + 'px';
             }
        }

        function applyHintFontSize() {
             if (modalQuestionDiv && hintFontSizeSlider) {
                const hintSize = hintFontSizeSlider.value + 'px';
                modalQuestionDiv.style.fontSize = hintSize;
            }
        }


         function handleHeightSettingChange() {
             applyHeightSettings();
             categoryHeightValueSpan.textContent = categoryHeightSlider.value + 'vh';
             scoreHeightValueSpan.textContent = scoreHeightSlider.value + 'vh';
        }

        function applyHeightSettings() {
            const catHeight = categoryHeightSlider.value + 'vh';
            const scoreHeight = scoreHeightSlider.value + 'vh';

            document.querySelectorAll('#gameBoard th.category-header').forEach(th => {
                th.style.height = catHeight;
            });
            document.querySelectorAll('#questionGrid td').forEach(td => {
                td.style.height = scoreHeight;
            });
        }


        // --- Edit Mode Logic ---
        function toggleEditMode() {
            isEditMode = !isEditMode;
            updateEditMode();
            toggleSettingsMenu(false);
        }

        function updateEditMode() {
             updateEditModeVisuals();
             if (isEditMode) {
                // alert("편집 모드가 켜졌습니다..."); // Alert removed for brevity
            } else {
                document.querySelectorAll('#categoryHeaders .category-header').forEach(th => {
                    const categoryName = th.dataset.categoryName;
                     if (th.dataset.displayState === 'answer') {
                         th.textContent = categoryName;
                         th.dataset.displayState = 'category';
                     }
                });
                applyFontSettings();
            }
        }

        function updateEditModeVisuals() {
            if (isEditMode) {
                toggleEditModeSettingsBtn.textContent = '편집 모드 끄기';
                toggleEditModeSettingsBtn.classList.add('edit-mode');
            } else {
                toggleEditModeSettingsBtn.textContent = '편집 모드 켜기';
                toggleEditModeSettingsBtn.classList.remove('edit-mode');
            }
             updateCategoryHeaderListeners();
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
             // Ensure modals are hidden on load explicitly
             closeModal('questionModal');
             closeModal('editModal');
             initializeBoard(); // This will now apply all initial settings
        });

    </script>

</body>
</html>
